'use strict';

const unplugin$1 = require('unplugin');
const compressing = require('compressing');
const path = require('path');
const fs = require('fs/promises');
const c = require('picocolors');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

function _interopNamespaceCompat(e) {
  if (e && typeof e === 'object' && 'default' in e) return e;
  const n = Object.create(null);
  if (e) {
    for (const k in e) {
      n[k] = e[k];
    }
  }
  n.default = e;
  return n;
}

const compressing__namespace = /*#__PURE__*/_interopNamespaceCompat(compressing);
const path__default = /*#__PURE__*/_interopDefaultCompat(path);
const fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
const c__default = /*#__PURE__*/_interopDefaultCompat(c);

class Log {
  static log(msg) {
    console.log(
      `${c__default.inverse(c__default.bold(c__default.magenta("UNPLUGIN COMPRESSING")))} ${msg}`
    );
  }
  static error(msg) {
    console.log(
      `${c__default.inverse(c__default.bold(c__default.red("UNPLUGIN COMPRESSING")))} ${c__default.red(msg)}`
    );
  }
  static success(msg) {
    console.log(
      `${c__default.inverse(c__default.bold(c__default.green("UNPLUGIN COMPRESSING")))} ${c__default.green(msg)}`
    );
  }
}

function normalizerSource(source, globalOptions) {
  if (typeof source === "string") {
    source = {
      source
    };
  }
  if (!Array.isArray(source)) {
    source = [source];
  }
  source = source.map((s) => {
    const defaultFormatter = "{{name}}.{{ext}}";
    return {
      source: s.source ?? "dist",
      outDir: s.outDir ?? globalOptions.outDir ?? "./",
      adapter: s.adapter ?? globalOptions.adapter ?? "zip",
      formatter: s.formatter ?? globalOptions.formatter ?? defaultFormatter,
      compressingOptions: s.compressingOptions ?? globalOptions.compressingOptions ?? void 0
    };
  });
  return source;
}
function getCompressName(source) {
  const { formatter, ...s } = source;
  const extra = {
    name: path__default.basename(s.source),
    ext: s.adapter
  };
  if (typeof formatter === "string") {
    const template = { ...s, ...extra };
    return formatter.replace(/\{\{(\w+)\}\}/g, ($_, $1) => {
      const value = template[$1];
      if (value !== void 0) {
        return value;
      }
      return $_;
    });
  }
  return formatter(s);
}
async function compress({
  source: rawSource = "dist",
  ...options
} = {}) {
  const source = normalizerSource(rawSource, options);
  await Promise.all(
    source.map(async (s) => {
      const compressAdapter = compressing__namespace[s.adapter];
      const resolvedSource = path.resolve(process.cwd(), s.source);
      const fileName = getCompressName(s);
      const resolvedOutput = path__default.join(
        path.resolve(process.cwd(), s.outDir),
        fileName
      );
      await compressAdapter.compressDir(resolvedSource, resolvedOutput, s.compressingOptions);
      const stat = await fs__default.stat(resolvedOutput);
      Log.success(`${fileName}	${stat.size} bytes`);
    })
  );
  return true;
}

const unplugin = unplugin$1.createUnplugin((options) => ({
  name: "unplugin-compress",
  enforce: "post",
  buildEnd() {
    let isCompress = false;
    process.on("beforeExit", async () => {
      if (isCompress)
        return;
      isCompress = true;
      Log.log("start compressing");
      let compressed = false;
      try {
        compressed = await compress(options);
      } catch (e) {
        Log.error(String(e));
      }
      if (compressed) {
        Log.success("compressed success");
      }
    });
  }
}));

exports.unplugin = unplugin;
